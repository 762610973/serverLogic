# serverLogic🎉️

> Go语言实现原神服务器的业务逻辑

## 基础模块

1. 需求分析结构搭建：实现玩家模块，玩家模块目前包含两个模块，~~基础模块~~和~~头像模块~~
2. 实现头像框修改和测试流程：判断用户有没有这个Icon，没有报错，有就修改
3. 架构微调和名片设置功能：将对外接口都移动到了玩家的主体下，同时增加名片设置功能，和头像设置功能的逻辑一样
4. 名字和签名系统（初遇公共管理模块：名字和签名的更新，对违禁词汇的简单处理，处理分为内部自带的违禁词库和不断更新的外界接口
5. main函数主线程设计前瞻：主要是利用协程
6. 定时器和违禁词库的启用:增加定时器，定时更新词库，这个更新词库的功能应该在服务器启动并且加载配置之后启动
7. 配置表：暂时手动写死一些违禁词汇的配置表，增加`icon,card,banword`，同步到其他函数中，并进行简单测试，梳理了整个测试的运行流程，函数调用情况
8. 增加人物阅历（经验）和等级换算:通过读取等级配置文件，增加等级经验模块，通过经验增加等级,并完成简单的测试
9. 增加~~任务模块~~和突破任务的判断；增加唯一突破任务模块，在固定的等级处需要突破相应的任务才能进行升级，理清了整个流程，进行了简单的测试
10. 游戏业务与Go基础的交锋--肆无忌惮使用map,在使用map时一定要注意是否产生读写冲突。玩家在打开背包时，进行了读，此时为了防止发生冲突，线程崩溃，会通过邮件的形式发送物品。还有比如一个排行榜，他是通过自己加锁，让玩家给排行榜模块发送数据，而不是排行榜去读取每个玩家的数据，排行榜读取每个玩家，那么每个玩家都要上锁，但是玩家给排行榜发送数据，只需要排行榜上锁
11. 世界等级降低和还原功能并测试（能灵活配置的切忌不要写成固定逻辑，防止后续重新打包编译），增加了世界等级降级的相关规则判定
12. 生日设置与生日判定：直接计算月和日，然后进行判定，纯计算效率也是很高的。
13. 展示名片功能：主要是验证从客户端传过来的名片数量以及是否存在重复的，有重复的则过滤
14. 展示阵容功能：这个模块与展示名片没有很大区别，总体思路是一致的
15. 封禁状态以及多用户登录：初步完成封禁状态的接口，保证总体流程跑通，设置多用户登录，这里由于没有客户端，所以监听那里采用了定时器，模拟玩家登录
16. 基础模块总结：完成一些字段以及字段的相关接口，为后续模块做铺垫

## 背包模块

17. 需求分析和物品识别功能：物品识别、物品增加、物品消耗（验证哪些能消耗（角色不可消耗））、物品使用、角色模块-->头像模块；增设背包模块，完成物品识别功能。
18. 补全头像模块功能：完善头像模块，可以增加头像、设置头像
19. 增加名片获得与角色好感度判定逻辑：名片模块涉及到好感度的一个数值判断，除此之外和头像模块没有什么区别
20. 打击恶意退款的物品增减：完成背包物品的增减，这里暂时提供GM权限的接口
21. 业务内循环的物品增减判断：当玩家背包物品数量不足以抵消时，是无法进行扣除的，增加这一步的判断，并使用goroutine`完成测试
22. 完成角色表配置和角色背包的流程接口：算法暂时没完成，下一节完成
23. 测试工具开发：对各个接口进行整合测试
24. 获得重复角色的材料转换功能：主要是根据玩法完成上节算法
25. 补全头像获得、头像功能完结（一表多读提高运算效率）：获得头像的前提是获得英雄，补齐整个流程
26. 补全名片获得：配置表和模块都需要在设计上解耦，和头像获得差不多
27. 武器背包：完成武器背包，独立物品的唯一key设计
28. 圣遗物背包完成：简单完成圣遗物背包，后续会完成整个
29. 烹饪背包：增加烹饪模块
30. 增加物品使用功能：背包的最后一个模块
31. 家园背包：初步完成，家园结构不是单一的结构，是最复杂的
32. 模块总结：所有物品的归纳，有具体逻辑的归到对应模块处理，没有的放到杂货铺，归为普通物品

## 掉落组模块

> 这个模块有待巩固完善

33. 模块需求分析：增加公共管理模块处理掉落数据，这个模块非常核心。保底设计、大数据测试（策划）、更新测试工具、UP池子、仓检（有利有弊，看如何使用了）
34. 一次单抽需要几个随机数：一个随机数是可以解决问题的，但是效率会很低，比如一个武器，有星级以及类别，如果只用一个随机数，那么需要把所有的组合情况都列出来，而采用多个随机数可以先抽取星数，比如二星，再从二星里面选择英雄
35. 数据表的二次数理：二次处理数据表，转化为自己想要的形式
36. 抽卡测试：简单完成随机抽卡
37. 如何理解伪随机：所有的随机都是根据算法生成的，没有真正的随机，这个可以参考英雄联盟的暴击率，这个是伪随机，并且是有补偿策略的。
38. 将掉落算法改为递归：除非只写一次以后不再改变，否则不要使用递归，会使后续维护困难
39. 伪随机1千万次单抽
40. 5星的保底算法：跟着大佬来
41. 4星的概率修正：跟着大佬来
42. 修复4星掉落概率并区分大小
43. 掉落测试
44. 掉落测试：10连5黄
45. 修复掉率bug
46. 角色模块与抽卡结果数据对接：仓检->更容易抽到已存在的角色或者更容易抽到不存在的角色
47. 获取玩家的角色拥有信息来支持仓检:获得玩家信息，以支持仓检
48. 独宠一人的仓检算法
49. 雨露均沾的仓检算法
50. 掉落组总结和后续计划：这个模块算法复杂，一般是交给专人来做

## 地图模块

51. 需求分析：蒙德地图、地图上的数据结构（采集物（矿物）、怪物、传送点、七天神像、神瞳、宝箱）、秘境地图（圣遗物秘境，顺便为后面圣遗物模块做支撑、风魔龙）
52. 地图识别和模块加载：地图识别和物品识别差不多，通过地图id来进行匹配识别地图，并且地图模块是和玩家绑定的，不同玩家展示的地图状态是不一样的。通过地图id能判定玩家位于哪个地图
53. 地图初始化流程设计:每个地图应该都有对应的结构，因为不同地图差别可能很大
54. 通过配置表实现全地图初始化：封装函数实现地图初始化
55. 增加秘境地图并实现地图时间自动初始化
56. 分析地图物件交互的数据：植物类、矿物类、怪物类，这三种击败后的逻辑是不一样的
57. 地图物件交互完成
58. 地图刷新的设计思路:实现不同类型的刷新，有日刷新、周刷新、自刷新
59. 地图整合刷新：将刷新加到具体的事件中
60. 普通怪和周长BOSS刷新
61. 个体刷新机制
62. 加入物品掉落组表格的处理
63. 地图事件的多重掉落奖励：导入四星掉落几率
64. 加入公共掉落组
65. 掉落算法增加大世界加成并导入地图事件
66. 增加风神瞳：宏定义一个不刷新的类别，检查刷新时，检查到这个类别，直接返回，不刷新
67. 七天神像的配置表处理：神像id、等级、消耗物品、消耗数量、掉落数量
68. 提交神瞳升级七天神像：等级、进度交给服务器存储，升级时获取配置，判断下一级的配置，判断背包中所需物品是否充足
69. 七天神像升级的进度处理：选择一级一级升和一次多级都是只有一个按钮，那么这个逻辑就是服务器去识别处理
70. 七天神像回血：按照时间回复，每次调用时去计算，没必要加一个定时器，损耗过高
71. 增加玩家主动触发的秘境刷新：副本是由玩家触发的，和之前的几个刷新机制是不一样的，无论进入几次，击败之后再次进入怪物都会刷新
72. 秘境奖励的事件验证：通常都会验证，有些是服务器、有些是客户端，但是通常有机制检测外挂、作弊行为来进行封号，但是实时验证有些游戏恐怕做不到，完成某一项奖励的时候验证秘境里的怪有没有被杀光
73. 增加体力验证和多选择掉落：不同物品掉落的算法不一样
74. 物品的权值掉落算法：增加权值掉落算法，增加多次掉落单独随机（跟着大佬来）
75. 物品的权值掉落算法：增加权值掉落算法，增加多次掉落单独随机（跟着大佬来）
76. 模块总结后续开发：秘境地图机制较特殊。总体完成了各部分功能。典型化功能基本实现。下一个模块是圣遗物。

## 圣遗物模块

77. 需求分析：圣遗物数据产生到消失的流程、圣遗物的属性，词条算法、强化、穿戴、卸下、套装
78. 主词条生成算法：主副词条，生成主词条类别
79. 主词条属性计算
80. 副词条生成算法
81. 升级算法并追加副词条
82. 还原游戏的词条生成算法
83. 圣遗物概率测试：概率测试非常重要，判断程序概率和策划的概率是否相匹配
84. 圣遗物的穿戴功能：圣遗物有五种类别，对应角色的5个部位，卸下、替换、穿戴，要考虑业务的拓展性，比如后面可以穿戴6个圣遗物
85. 圣遗物卸下：装备脱落时要做验证拦截
86. 圣遗物替换（难点）：很容易出错。判断身上之前有没有装备，判断要替换的装备是否在别人的身上
87. 套装激活：客户端直接穿套装，不验证战斗，客户端需要做显示套装
88. 模块总结：距离头的生成，属性计算，强化以及穿戴替换

## 武器模块
89. 需求分析：强化、突破、精炼、穿和卸下、替换
90. 武器强化：不存在则返回，经验赋值，进入死循环升级
91. 武器突破：武器星级突破需要检测武器等级，根据等级来突破
92. 武器精炼：武器除了强化和突破，还能精炼，同名武器材料
93. 武器穿戴和卸下：这个和圣遗物逻辑差不多，没区别
94. 武器替换（难点）：穿一个武器考虑两点：身上是否有一把之前的武器，第二个现在穿的这个武器是否在某一个人的身上，那么穿的时候还需要把现在的武器放到别人身上


## 后续模块
1. 为什么游戏服务器关闭前最好安全下线：数据不是实时写入数据库的，一个思路是强行踢下线，然后对数据存储（英雄联盟就是这样，快赢了突然被踢了）
2. 按照预期想法关闭服务器,而不是直接关闭main函数
 ```go
channelSignal := make(chan os.Signal)
signal.Notify(channelSignal,syscall.SIGINT)
```
3. player下有很多模块，可以采用一个`map[string]interface{}`来进行处理，使得模块更容易被管理
4. 玩家线程安全问题：
   1. 所有物品改动由玩家发起
   2. 第三方给予东西一律统一接口，比如邮件，尽量减少锁的使用
   3. 扣除物品，给玩家发送一条消息，由玩家线程主动去申请
   4. 玩家通过webSocket接入服务器当做主线程是可以的，主要处理玩家数据、收消息、发消息
5. 多端登录顶号问题：
   1. 确保每个玩家的数据只能同时被一个线程处理：高速A有个B，然后和B连接
   2. 断线重连不属于多端登录考虑范畴之内
   3. 没有下线功能的话，上过线的角色对象将用于存在内存中


## Tips

- 概率算法：拿到配置比较权重，然后来随机出奖励
- 所有有利于项目开发的设计都是合理的
- 一个字段的状态最好不要用bool值，用int值更加容易扩展
- 系统给玩家发送物品一般通过邮件来做，而不是直接加到背包，这是为了保证物品安全性
- 多参数验证问题：客户端运行环境不受限，客户端破解容易，服务器的一个重要职责是验证数据，云游戏是可以相信的，但是如果在玩家端，什么都不可以信，都要验证
- 对内接口：内部逻辑调用的接口
- 对外接口：和客户端打交道的接口，将所有的对外接口放到player下面
- receive开头的直接跟客户端打交道，接受客户端消息，然后调用内部接口
- 某些场景需要进行一些判断比较，我们可以采用const定义的方式来实现，而不是写死，这些变量从配置表里读取，增加了可扩展性。
